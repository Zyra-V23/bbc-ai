"""
Database module for common smart contract vulnerabilities
"""

import os
import logging
from typing import Dict, Any, List, Optional
import psycopg2
from psycopg2 import sql
from psycopg2.extras import RealDictCursor
import re

from .config import config

class VulnerabilityDatabase:
    """PostgreSQL database handler for common vulnerabilities"""
    
    def __init__(self, db_url: str = os.environ.get("DATABASE_URL")):
        """Initialize the database connection"""
        self.db_url = db_url
        self.conn = None
        self.cursor = None
        
        # Connect to the database
        self.initialize()
    
    def initialize(self):
        """Initialize the database and create tables if they don't exist"""
        try:
            self.conn = psycopg2.connect(self.db_url)
            self.conn.autocommit = False
            self.cursor = self.conn.cursor(cursor_factory=RealDictCursor)
            
            # Create tables if they don't exist
            self._create_tables()
            
            # Commit changes
            self.conn.commit()
            
        except psycopg2.Error as e:
            logging.error(f"Database initialization error: {str(e)}")
            if self.conn:
                self.conn.rollback()
            raise
    
    def _create_tables(self):
        """Create necessary database tables if they don't exist"""
        # Vulnerability categories table
        self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS vulnerability_categories (
            id SERIAL PRIMARY KEY,
            name TEXT NOT NULL UNIQUE,
            description TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)
        
        # Vulnerabilities table
        self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS vulnerabilities (
            id SERIAL PRIMARY KEY,
            category_id INTEGER REFERENCES vulnerability_categories(id),
            name TEXT NOT NULL,
            description TEXT NOT NULL,
            severity TEXT NOT NULL,
            recommendation TEXT,
            code_sample TEXT,
            detection_pattern TEXT,
            cvss_score REAL DEFAULT 0.0,
            cvss_vector TEXT,
            references TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)
        
        # Tags table
        self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS vulnerability_tags (
            id SERIAL PRIMARY KEY,
            name TEXT NOT NULL UNIQUE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """)
        
        # Vulnerability-tag relationship table
        self.cursor.execute("""
        CREATE TABLE IF NOT EXISTS vulnerability_tag_map (
            vulnerability_id INTEGER REFERENCES vulnerabilities(id) ON DELETE CASCADE,
            tag_id INTEGER REFERENCES vulnerability_tags(id) ON DELETE CASCADE,
            PRIMARY KEY (vulnerability_id, tag_id)
        )
        """)
    
    def add_category(self, name: str, description: str = "") -> int:
        """Add a new vulnerability category"""
        try:
            self.cursor.execute("""
            INSERT INTO vulnerability_categories (name, description)
            VALUES (%s, %s)
            RETURNING id
            """, (name, description))
            
            category_id = self.cursor.fetchone()['id']
            self.conn.commit()
            
            return category_id
        except psycopg2.Error as e:
            logging.error(f"Error adding category: {str(e)}")
            self.conn.rollback()
            raise
    
    def get_categories(self) -> List[Dict[str, Any]]:
        """Get all vulnerability categories"""
        try:
            self.cursor.execute("""
            SELECT * FROM vulnerability_categories ORDER BY name
            """)
            
            return list(self.cursor.fetchall())
        except psycopg2.Error as e:
            logging.error(f"Error getting categories: {str(e)}")
            raise
    
    def add_vulnerability(self, name: str, description: str, severity: str,
                         category_id: Optional[int] = None,
                         recommendation: str = "", code_sample: str = "",
                         detection_pattern: str = "", cvss_score: float = 0.0,
                         cvss_vector: str = "", references: str = "") -> int:
        """Add a new vulnerability to the database"""
        try:
            self.cursor.execute("""
            INSERT INTO vulnerabilities (
                name, description, severity, category_id, recommendation,
                code_sample, detection_pattern, cvss_score, cvss_vector, references
            )
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
            """, (
                name, description, severity, category_id, recommendation,
                code_sample, detection_pattern, cvss_score, cvss_vector, references
            ))
            
            vulnerability_id = self.cursor.fetchone()['id']
            self.conn.commit()
            
            return vulnerability_id
        except psycopg2.Error as e:
            logging.error(f"Error adding vulnerability: {str(e)}")
            self.conn.rollback()
            raise
    
    def get_vulnerabilities(self, category_id: Optional[int] = None,
                           severity: Optional[str] = None,
                           tag: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get vulnerabilities with optional filtering"""
        try:
            query = """
            SELECT v.*, c.name as category_name
            FROM vulnerabilities v
            LEFT JOIN vulnerability_categories c ON v.category_id = c.id
            """
            
            conditions = []
            params = []
            
            if category_id is not None:
                conditions.append("v.category_id = %s")
                params.append(category_id)
            
            if severity is not None:
                conditions.append("v.severity = %s")
                params.append(severity)
            
            if tag is not None:
                query += """
                JOIN vulnerability_tag_map tm ON v.id = tm.vulnerability_id
                JOIN vulnerability_tags t ON tm.tag_id = t.id
                """
                conditions.append("t.name = %s")
                params.append(tag)
            
            if conditions:
                query += " WHERE " + " AND ".join(conditions)
            
            query += " ORDER BY v.severity DESC, v.name"
            
            self.cursor.execute(query, params)
            
            return list(self.cursor.fetchall())
        except psycopg2.Error as e:
            logging.error(f"Error getting vulnerabilities: {str(e)}")
            raise
    
    def get_vulnerability(self, vulnerability_id: int) -> Optional[Dict[str, Any]]:
        """Get a specific vulnerability by ID"""
        try:
            self.cursor.execute("""
            SELECT v.*, c.name as category_name
            FROM vulnerabilities v
            LEFT JOIN vulnerability_categories c ON v.category_id = c.id
            WHERE v.id = %s
            """, (vulnerability_id,))
            
            result = self.cursor.fetchone()
            
            if result:
                # Get tags for this vulnerability
                self.cursor.execute("""
                SELECT t.name
                FROM vulnerability_tags t
                JOIN vulnerability_tag_map tm ON t.id = tm.tag_id
                WHERE tm.vulnerability_id = %s
                """, (vulnerability_id,))
                
                tags = [row['name'] for row in self.cursor.fetchall()]
                result['tags'] = tags
            
            return result
        except psycopg2.Error as e:
            logging.error(f"Error getting vulnerability {vulnerability_id}: {str(e)}")
            raise
    
    def add_tag(self, name: str) -> int:
        """Add a new tag"""
        try:
            self.cursor.execute("""
            INSERT INTO vulnerability_tags (name)
            VALUES (%s)
            ON CONFLICT (name) DO NOTHING
            RETURNING id
            """, (name,))
            
            result = self.cursor.fetchone()
            
            if result:
                tag_id = result['id']
            else:
                # If ON CONFLICT happened, get the existing ID
                self.cursor.execute("""
                SELECT id FROM vulnerability_tags WHERE name = %s
                """, (name,))
                tag_id = self.cursor.fetchone()['id']
            
            self.conn.commit()
            
            return tag_id
        except psycopg2.Error as e:
            logging.error(f"Error adding tag: {str(e)}")
            self.conn.rollback()
            raise
    
    def get_tags(self) -> List[Dict[str, Any]]:
        """Get all tags"""
        try:
            self.cursor.execute("""
            SELECT * FROM vulnerability_tags ORDER BY name
            """)
            
            return list(self.cursor.fetchall())
        except psycopg2.Error as e:
            logging.error(f"Error getting tags: {str(e)}")
            raise
    
    def add_vulnerability_tag(self, vulnerability_id: int, tag_id: int) -> bool:
        """Associate a tag with a vulnerability"""
        try:
            self.cursor.execute("""
            INSERT INTO vulnerability_tag_map (vulnerability_id, tag_id)
            VALUES (%s, %s)
            ON CONFLICT (vulnerability_id, tag_id) DO NOTHING
            """, (vulnerability_id, tag_id))
            
            self.conn.commit()
            
            return True
        except psycopg2.Error as e:
            logging.error(f"Error adding vulnerability tag: {str(e)}")
            self.conn.rollback()
            return False
    
    def search_vulnerabilities(self, query: str) -> List[Dict[str, Any]]:
        """Search vulnerabilities by name, description, or code sample"""
        try:
            self.cursor.execute("""
            SELECT v.*, c.name as category_name
            FROM vulnerabilities v
            LEFT JOIN vulnerability_categories c ON v.category_id = c.id
            WHERE v.name ILIKE %s
            OR v.description ILIKE %s
            OR v.code_sample ILIKE %s
            ORDER BY v.severity DESC, v.name
            """, (f"%{query}%", f"%{query}%", f"%{query}%"))
            
            return list(self.cursor.fetchall())
        except psycopg2.Error as e:
            logging.error(f"Error searching vulnerabilities: {str(e)}")
            raise
    
    def check_code_for_vulnerabilities(self, code: str) -> List[Dict[str, Any]]:
        """
        Check a code snippet for known vulnerabilities using detection patterns
        
        This function uses regex patterns stored in the detection_pattern field
        to identify potential vulnerabilities in the provided code.
        """
        try:
            # Get all vulnerabilities with detection patterns
            self.cursor.execute("""
            SELECT v.*, c.name as category_name
            FROM vulnerabilities v
            LEFT JOIN vulnerability_categories c ON v.category_id = c.id
            WHERE v.detection_pattern IS NOT NULL AND v.detection_pattern != ''
            """)
            
            vulnerabilities = list(self.cursor.fetchall())
            detected = []
            
            for vuln in vulnerabilities:
                pattern = vuln['detection_pattern']
                if pattern and re.search(pattern, code, re.IGNORECASE | re.MULTILINE):
                    detected.append(vuln)
            
            return detected
        except psycopg2.Error as e:
            logging.error(f"Error checking code for vulnerabilities: {str(e)}")
            raise
    
    def seed_common_vulnerabilities(self):
        """Seed the database with common smart contract vulnerabilities"""
        try:
            # Add categories
            access_control_id = self.add_category(
                "Access Control", 
                "Vulnerabilities related to improper authorization and access management"
            )
            
            arithmetic_id = self.add_category(
                "Arithmetic Issues",
                "Vulnerabilities related to arithmetic operations, overflows, and underflows"
            )
            
            reentrancy_id = self.add_category(
                "Reentrancy",
                "Vulnerabilities allowing attackers to re-enter contracts before state updates"
            )
            
            dependency_id = self.add_category(
                "Dependency",
                "Vulnerabilities stemming from unsafe dependencies or third-party interactions"
            )
            
            logic_id = self.add_category(
                "Logic Issues",
                "Vulnerabilities related to business logic flaws and contract design"
            )
            
            # Add vulnerabilities with detection patterns
            
            # Reentrancy
            reentrancy_vuln_id = self.add_vulnerability(
                name="Reentrancy Attack",
                description="The contract performs an external call before updating its state, allowing an attacker to re-enter the contract and exploit the unupdated state.",
                severity="critical",
                category_id=reentrancy_id,
                recommendation="Follow the checks-effects-interactions pattern: First perform all state changes, then interact with external contracts or addresses. Consider using reentrancy guards.",
                code_sample="""
function withdraw(uint256 amount) public {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    
    // Vulnerability: External call before state update
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "Transfer failed");
    
    // State update happens after external call
    balances[msg.sender] -= amount;
}
                """,
                detection_pattern=r"\.call\{value:.*\}\([^\)]*\).*[\s\S]*-=",
                cvss_score=9.1,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
                references="https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"
            )
            
            # TX.Origin
            tx_origin_vuln_id = self.add_vulnerability(
                name="Using tx.origin for Authorization",
                description="Using tx.origin for authorization allows phishing attacks because tx.origin refers to the original transaction sender, not the immediate caller (msg.sender).",
                severity="high",
                category_id=access_control_id,
                recommendation="Always use msg.sender instead of tx.origin for authorization checks.",
                code_sample="""
function transferOwnership(address newOwner) public {
    // Vulnerability: Using tx.origin for authorization
    require(tx.origin == owner, "Not authorized");
    owner = newOwner;
}
                """,
                detection_pattern=r"tx\.origin\s*==",
                cvss_score=8.2,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N",
                references="https://consensys.github.io/smart-contract-best-practices/attacks/tx-origin/"
            )
            
            # Integer Overflow/Underflow
            overflow_vuln_id = self.add_vulnerability(
                name="Integer Overflow/Underflow",
                description="Arithmetic operations that exceed the maximum or minimum values of their types may wrap around, causing unexpected behavior.",
                severity="high",
                category_id=arithmetic_id,
                recommendation="Use SafeMath library for Solidity versions below 0.8.0. For Solidity 0.8.0 and above, use the built-in overflow/underflow protection or the unchecked block for gas optimization when overflow/underflow is impossible.",
                code_sample="""
// Solidity < 0.8.0
function transfer(address to, uint256 amount) public {
    // Vulnerability: No protection against underflow
    balances[msg.sender] -= amount;
    balances[to] += amount;
}
                """,
                detection_pattern=r"(?<!\+\+|--|\+=|-=|\*=|/=|%=|unchecked)(\+|-|\*|/|\+\+|--|\+=|-=|\*=|/=|%=)(?![^\n]*\bSafeMath\b)",
                cvss_score=7.5,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
                references="https://consensys.github.io/smart-contract-best-practices/attacks/arithmetic/"
            )
            
            # Add more vulnerabilities...
            unchecked_return_id = self.add_vulnerability(
                name="Unchecked Return Values",
                description="Not checking the return values of external calls can lead to silent failures and unexpected behavior.",
                severity="medium",
                category_id=dependency_id,
                recommendation="Always check the return values of external calls and handle potential failures.",
                code_sample="""
function withdraw(uint256 amount) public {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    balances[msg.sender] -= amount;
    
    // Vulnerability: Unchecked return value
    address(msg.sender).call{value: amount}("");
}
                """,
                detection_pattern=r"\.call\{[^\}]*\}\([^\)]*\);(?!\s*(?:require|assert|if))",
                cvss_score=5.5,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L",
                references="https://consensys.github.io/smart-contract-best-practices/recommendations/#handle-errors-in-external-calls"
            )
            
            # Add more vulnerabilities
            delegatecall_id = self.add_vulnerability(
                name="Unsafe Delegatecall",
                description="Improper use of delegatecall can allow an attacker to manipulate the contract's storage and behavior.",
                severity="critical",
                category_id=dependency_id,
                recommendation="Use delegatecall with extreme caution. Ensure that the target contract is trusted and validate all inputs.",
                code_sample="""
function execute(address target, bytes memory data) public {
    // Vulnerability: Unsafe delegatecall
    (bool success, ) = target.delegatecall(data);
    require(success, "Execution failed");
}
                """,
                detection_pattern=r"\.delegatecall\(",
                cvss_score=9.8,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                references="https://consensys.github.io/smart-contract-best-practices/attacks/delegatecall/"
            )
            
            # Add tags
            erc20_tag_id = self.add_tag("ERC20")
            erc721_tag_id = self.add_tag("ERC721")
            defi_tag_id = self.add_tag("DeFi")
            solidity_tag_id = self.add_tag("Solidity")
            
            # Associate tags with vulnerabilities
            self.add_vulnerability_tag(reentrancy_vuln_id, defi_tag_id)
            self.add_vulnerability_tag(reentrancy_vuln_id, solidity_tag_id)
            self.add_vulnerability_tag(tx_origin_vuln_id, solidity_tag_id)
            self.add_vulnerability_tag(overflow_vuln_id, solidity_tag_id)
            self.add_vulnerability_tag(overflow_vuln_id, erc20_tag_id)
            self.add_vulnerability_tag(unchecked_return_id, solidity_tag_id)
            self.add_vulnerability_tag(delegatecall_id, solidity_tag_id)
            
            logging.info("Successfully seeded vulnerability database")
            
            return True
        except Exception as e:
            logging.error(f"Error seeding vulnerabilities: {str(e)}")
            self.conn.rollback()
            raise
    
    def close(self):
        """Close the database connection"""
        if self.conn:
            self.conn.close()